


给二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

 

<img width="406" height="591" alt="image" src="https://github.com/user-attachments/assets/39a95c75-6ba5-45bc-a652-34c3aa64bfd3" />

这道题要求二叉树的层序遍历，也就是按从上到下、从左到右的顺序，一层一层地访问所有节点。这是二叉树的一个基础且重要的遍历方式。

核心思路：

使用队列进行广度优先BFS

模拟运行

```
    3
   / \
  9  20
     / \
    15  7
```

初始情况：队列 q = [3]，结果集 res = []。

第一层：队列长度=1。取出3，值存入[3]，并将9和20加入队列。（这是第二层即将要处理的部分）此时res = [[3]]，队列 q = [9, 20]。


第二层：队列长度=2（此时是第一层结果之后），继续处理，取出9，值存入[9]，无子节点。

取出20，值存入[20]，并将15和7加入队列。

本层结束，[9, 20]加入结果集。此时res = [[3], [9, 20]]，队列 q = [15, 7]。

第三层：队列长度=2。取出15和7，值存入[15, 7]，它们都没有子节点。

将[15, 7]加入结果集。此时res = [[3], [9, 20], [15, 7]]，队列变空，循环结束。



关键部分的流程
```
// 处理当前层的所有节点
for (int i = 0; i < levelSize; i++) {
    // ① 看队首：获取当前要处理的节点
    TreeNode* node = q.front();  // node 指向这个节点
    
    // ② 删队首：这个节点已经从队列中移除
    q.pop();                     
    
    // ③ 处理节点：记录值，把子节点加入队列
    currentLevel.push_back(node->val);
    
    if (node->left) q.push(node->left);
    if (node->right) q.push(node->right);
}
```

主要思路：

第一步：初始化

第二步：按层循环

第三步：返回结果
