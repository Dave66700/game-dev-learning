## 问题分析：

给你一个整数 n，返回和为 n 的完全平方数的最少数量。

完全平方数：1, 4, 9, 16, 25, ...（即整数的平方）

n = 12：12 = 4 + 4 + 4（3个平方数），输出 3

（当然还有别的利用完全平方数凑的可能性，例如9+1+1+1，输出4，但是这里我们求得是最小值）

n = 13：13 = 4 + 9（2个平方数），输出 2


## 动态规划思路

**1.转化为：完全背包问题**

背包容量：n

物品：完全平方式，1，4，9，16

目标：用最少的物品，恰好完全装满背包

**2.状态定义：**

dp[i]数组表示：组成整数i需要的最少完全平方数的数量

举例：如果 dp[12] = 3，表示组成12最少需要3个平方数。

**3.状态转移方程的理解**

dp[i] = min(dp[i], dp[i - j*j] + 1)

对于每个i，我们尝试所有的可能的完全平方数

dp[i - j*j]：组成 i - j*j 所需的最少平方数

+1：加上当前的平方数 j*j

min：取所有可能中的最小值

**这里举个例子很好理解：**

模拟dp[9]

最开始dp[9]默认值是∞，因此取min的时候一定是后者。

我们可以把这个9拆开，因为完全平方数小于9的只有1、4、9

所以dp[i - j*j] + 1

只能这么拆开：9-1*1，9-2*2，9-3*3

- 情况1：j=1 → dp[9-1*1] + 1 = dp[8] + 1
  - 含义：先拼出8（用某种最优方式，之前算出来的），然后加个1
  - dp[8]就是之前求出来的最优方式，也就是dp数组的作用
- 情况2：j=2 → dp[9-2*2] + 1 = dp[5] + 1  
  - 含义：先拼出5（用最优方式），然后加个4
- 情况3：j=3 → dp[9-3*3] + 1 = dp[0] + 1
  - 含义：先拼出0（什么都不用），然后直接加个9

最后return dp[n];
**4.初始化**

dp[0] =0: 组成0，需要0个完全平方数（数学上成立）

dp[i]初始化，为最大数，以便于后面min函数来筛选

## 函数部分

```
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1,INT_MAX)
//我们需要存储 dp[0] 到 dp[n]，总共 n+1 个状态。
        int dp[0] = 0;----------->不用再定义了，已经是int dp[o] = o

      for(int i =1;i<=n;i++)--------- 遍历所有"背包容量"
{
    for(int j = 1;j * j<i;j++)---------->小于等于啊，dp[9]边界不要忘记
    {dp[i] = min(dp[i],dp[i-j*j]+1);}

}
return dp[n];
    }
};
```
