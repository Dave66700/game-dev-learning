# 234.回文链表

<img width="453" height="365" alt="image" src="https://github.com/user-attachments/assets/d4af4079-667d-4f2d-85cc-e0f48b61c063" />

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

## 解题思路

- 第一步：找到链表的中间节点。快慢指针法

  - 慢指针每次走一步，快指针每次走两步。
  - 当快指针走到链表末尾时，慢指针正好指向链表的中间节点

- 第二步：反转链表的后半部分。

  - 从中间节点开始，对后半部分链表原地反转

- 第三步：比较前后两部分

  - 两个指针。一个链表头部和另一个中间开始的头部。逐个比较节点值。

## 理解

### 链表反转部分

目标是：从 slow 指针指向的节点开始是： A -> B -> C -> null。

我们的目标是把它变成 C -> B -> A -> null

关键节点的作用

- curr (当前节点)：我们现在正在处理哪个节点。
- prev：反转后，应该变成 curr 要指向的目标
- nextTemp (下一个节点)：用来临时保存 curr 原本的“下一个节点”是谁。
  - 如果不保存，一旦我们修改了 curr->next 的指向，就再也找不到它了。
 
```
ListNode *prev = nullptr;
ListNode *curr = slow;

// 循环遍历要反转的链表，直到 curr 指向 nullptr（即到达原链表的末尾）
while (curr != nullptr) {
    // 1. 暂存下一个节点
    // 因为下一步要改变 curr->next 的指向，如果不暂存，就会丢失对后面节点的引用，无法继续遍历。
    ListNode *nextTemp = curr->next;

    // 2. 反转指针：将当前节点的 next 指向前一个节点 (prev)
    // 这是反转的核心操作。原本 curr 指向下一个节点，现在让它指向前一个。
    curr->next = prev;

    // 3. 移动 prev 指针：prev 向前移动，准备处理下一个节点
    // 现在，当前节点已经处理完毕，它将成为下一个节点的“前一个节点”。
    prev = curr;

    // 4. 移动 curr 指针：curr 向前移动，指向之前暂存的下一个节点，继续循环
    curr = nextTemp;
}
```

### 比较前后两部分

问题一：

ListNode *right = prev; // right 指向反转后的后半部分头部

当循环结束时，curr 已经因为 curr = nextTemp 这个操作，移动到了原链表的最后一个节点的 next，也就是 nullptr。

而 prev 此时指向的是原链表的最后一个节点，也就是反转后新链表的第一个节点。

问题二：

 while (right != nullptr)  // 只需比较后半部分长度即可

 因为前半部分和后半部分是一一对应的：

- 偶数长度（如 1-2-2-1）：前后半部分长度相等，比较完后半部分就相当于比较完整个链表

- 奇数长度（如 1-2-3-2-1）：后半部分比前半部分少一个中间节点，但中间节点是“对称轴”，不需要比较。比较完后半部分的所有节点（1 和 2），前半部分对应的节点（1 和 2）也验证完了

用较短的“后半部分”作为循环条件，刚好比较完所有需要比较的节点，不多不少。
