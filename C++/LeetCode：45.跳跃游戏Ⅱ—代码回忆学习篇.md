```

// 函数定义：输入一个整数数组nums，返回到达最后一个位置的最少跳跃次数
int jump(vector<int>& nums) {
    // 获取数组的长度
    int n = nums.size();
    
    // 特殊情况处理：如果数组长度小于等于1，说明已经在终点或没有元素
    // 不需要跳跃，直接返回0
    if (n <= 1) return 0;
    
    // jumps：记录到目前为止已经进行的跳跃次数
    // 初始为0，因为还没开始跳
    int jumps = 0;
    
    // cur_end：当前这一次跳跃能够到达的最远位置
    // 初始为0，表示第一次跳跃从位置0开始
    int cur_end = 0;
    
    // farthest：在所有已经探索过的位置中，能够到达的最远位置
    // 初始为0，表示还没有探索任何位置
    int farthest = 0;
    
    // 遍历数组，从第一个位置开始，到倒数第二个位置结束
    // 注意：只需要遍历到n-2，因为如果到达n-1，就说明已经在终点了
    
    for (int i = 0; i < n - 1; i++) {
        // 更新farthest：比较之前记录的最远位置和当前位置能跳到的最远位置
        // i + nums[i]：从位置i能够跳到的最远位置
        // max(farthest, i + nums[i])：取两者中更大的值
        farthest = max(farthest, i + nums[i]);
        
        // 检查是否到达了当前跳跃的边界
        // i == cur_end：当前位置等于当前跳跃能到达的最远位置
        // 这意味着当前这一次跳跃的所有可能性都已经探索完了
        if (i == cur_end) {
            // 必须要进行下一次跳跃，跳跃次数加1
            jumps++;
            
            // 更新下一次跳跃能到达的最远位置
            // 使用之前记录的最远可达位置作为新的边界
            cur_end = farthest;
            
            // 提前终止条件：如果新的边界已经能够到达或超过最后一个位置
            // 说明不需要继续探索了，可以直接跳出循环
            if (cur_end >= n - 1) {
                break;
            }
        }
        // 如果i != cur_end，说明还在当前跳跃的范围内
        // 继续向前探索，寻找更远的可达位置
    }
    
    // 返回总的跳跃次数
    return jumps;
}

```
