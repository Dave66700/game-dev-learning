# dp 数组：动态规划的记忆核心

dp数组——动态规划的灵魂，专门用来存储和记忆子问题的结果。

## 在打家劫舍问题具体作用

站在第 j 间房子前，面临选择：

偷这间：获得 nums[j] + 偷到第 j-2 间为止的最大金额

不偷这间：保持偷到第 j-1 间为止的最大金额

**关键问题：你怎么知道"偷到第 j-2 间为止的最大金额"是多少？**

答案：查 dp 数组！dp[j-2] 早就帮你记好了！

dp 数组就像一个备忘录，记录了所有"历史最优解"！

## 实际过程理解：
```

时间线：
时刻0：dp[0] = 2                     ← 记录：只考虑第0间，最多得2元
时刻1：dp[1] = max(2, 7) = 7         ← 记录：考虑前2间，最多得7元
时刻2：要计算dp[2]，需要知道：
        - 不偷第2间：查dp[1] = 7
        - 偷第2间：9 + dp[0] = 9 + 2 = 11
        → dp[2] = max(7, 11) = 11    ← 新的记录诞生！
时刻3：要计算dp[3]，查：
        - dp[2] = 11（不偷第3间）
        - 3 + dp[1] = 3 + 7 = 10（偷第3间）
        → dp[3] = max(11, 10) = 11

```

## dp 数组和普通变量

 - 对于普通变量来讲

 算到第四间房子，历史信息里面偷到第二间为止的最大金额已经被覆盖

- 而对于dp数组，vector<int> dp (n,0) 

 dp数组保留了关键的历史信息

 ## dp数组的思想本质

- 避免重复计算

 如果没有dp数组，则会有在递归的时候大量重复性计算

- 自底向上构建 

```
dp[0] → 最简单（只有1间房）
dp[1] → 稍微复杂（2间房）
dp[2] → 用dp[0]和dp[1]的结果计算
dp[3] → 用dp[1]和dp[2]的结果计算
...
dp[j] → 用dp[j-1]和dp[j-2]的结果计算

```
 
