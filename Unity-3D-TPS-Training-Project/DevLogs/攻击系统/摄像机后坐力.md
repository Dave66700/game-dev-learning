## 在此之前先明确打击感的真相

**打击感 = 命中确认 × 时间变化 × 视觉反馈 × 相机反馈 × 音频反馈**

接下来

点击既可以让敌人掉血，也可以让相机抖动，让玩家体验到后坐力


## Step1：变量的声明
```
public float recoilAmount = 2f;
public float recoilRecoverSpeed = 8f;
private float currentRecoil;
```

- 后坐力强度：每次设计枪口上扬角度
- 后坐力回复速度：每秒恢复的角度
- 当前剩余的后坐力：还需要多少度回复

## Step2：命中时增加后坐力

在Attack()里面，命中之后
```
currentRecoil += recoilAmount;

```

- recoilAmount =2f; 射击一次就增加2
- 连续射击则累加

## Step3 update里面恢复
```
void Update()
{
    RecoverRecoil();
}
```

## Step4 函数本身
```
void RecoverRecoil()
{
    if (currentRecoil > 0)
    {
        float recoilStep = recoilRecoverSpeed * Time.deltaTime;
        cameraTransform.localRotation *= Quaternion.Euler(recoilStep, 0f, 0f);
        currentRecoil -= recoilStep;
    }
}

```

### 逻辑：

检查是否还有后坐力需要恢复？

若进入了if函数体，则说明需要

此时计算这一帧应该恢复的角度

将这个计算好的角度，给到旋转的四元数的参数中

减少剩余后坐力，这个会持续的和if进行联动

只要if判断后坐力还有，那么就一定会继续进入函数体

### 为什么是 recoilStep？

恢复的时候，也就是枪口回正的时候，摄像机应当低头。而设计的时候应该抬头，也就是向上旋转。

- localRotation *= Quaternion.Euler(...)

- 增量旋转（delta rotation）
  - 它不是“设置角度”，而是：
  - 在当前方向基础上继续旋转，所以符号方向必须严格相反：
  - 抬枪  = -X
  - 恢复  = +X


### 函数关键部分和四元数

cameraTransform.localRotation *= Quaternion.Euler(-recoilStep, 0f, 0f);

Quaternion.Euler	一种方法	将欧拉角转换为四元数

(-recoilStep, 0f, 0f)	Vector3类型	绕X轴旋转负角度（向上）

### 什么是四元数？

四元数是Unity中表示旋转的数学工具，解决了欧拉角的万向锁问题。

```
Quaternion q = new Quaternion(x, y, z, w);
```

- 没必要直接修改这些值，直接使用unity提供的方法
- Quaternion.Euler 方法
  - 创建一个绕X轴旋转angle度的四元数
  - Quaternion rotation = Quaternion.Euler(angle, 0, 0);
 

