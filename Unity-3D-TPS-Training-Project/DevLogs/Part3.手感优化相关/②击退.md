先界定击退反应到底属于谁的职能？

“击退是攻击造成的效果，为什么不写在 PlayerAttack，而写在 EnemyHealth？”

我们来拆解一下角色指责的归属

游戏里面有三种角色指责

Ⅰ攻击者 playerAttack “我造成伤害”

Ⅱ收集者 EnenmyHealth “我受到影响”

Ⅲ规则层 GameManager  胜负、计分

击退属于谁？

击退是“受击反应”，不是“攻击行为”。

击退的原理：

射线击中敌人的时候：

```
RaycastHit hit;

```

hit包含的功能：

| 数据           | 意义     |
| ------------ | ------ |
| hit.point    | 击中的位置  |
| hit.normal   | 表面法线方向 |
| hit.collider | 被打到的物体 |

怎样算是击退？

敌人能从受击方向反向移动

## Step1 给 EnemyHealth 加“击退能力”


在 EenmyHealth中添加：

```
public float hitForce = 5f;
private Rigidbody rb;

```
Start()里面添加

rb = GetComponent<Rigidbody>();

这里我想要再详细说说Get Component从哪里获得这些东西？

rb = GetComponent<Rigidbody>();
到底是从哪里“拿”的？

它拿的是：
这个 EnemyHealth 脚本“所挂载的那个 GameObject”上的 Rigidbody


记得：
敌人身上必须有 Rigidbody

（没有就 Add Component → Rigidbody）

并且：

勾选 Use Gravity ✔

勾选 Freeze Rotation X Z（防止倒地乱滚）

## Step2- 修改TakeDamage方法签名
```
public void TakeDamage(float damage)
```
改成
```
public void TakeDamage(int damage, Vector3 hitDirection)
```

在函数内添加功能

AddForce相关内容的拓展

**rb.AddForce:**

给角色的刚体添加了一个冲击力

相当于：
- 被击中的击退
- 爆炸、跳跃的瞬间推力
- 物理交互的瞬间力


**hitDirection * hitForce**

Vector3 hitDirection * float hitForce
- hitDirection：Vector3 类型，力的方向（单位向量）
- hitForce：float 类型，力的大小


**ForceMode.Impulse**

一共有四种力的模式


|ForceMode | 作用|	公式|	适用场景|
| ------------ | ------ |----|----|
|Impulse	|瞬间冲击力|	force * 1	|子弹击中、跳跃、爆炸|
|Force|	持续力（每帧）|	force * Time.deltaTime|	火箭推进、持续风力|
|VelocityChange	|瞬间速度改变	|force * 1（忽略质量）	| 瞬间传送、重置速度|
|Acceleration|	持续加速度|	force * Time.deltaTime（忽略质量）|	恒定加速度运动|


## Step3 扣血之后加入击退

```
currentHealth -= damage;

StartCoroutine(FlashRed());

if (rb != null)
{
    rb.AddForce(hitDirection * hitForce, ForceMode.Impulse);---->新增的部分
}

if (currentHealth <= 0)
{
    Die();
}

```

这里重点Step2 已经说过了

现在就提一个事情

为什么要检查 rb != null？

安全做法：避免 NullReferenceException
```
if (rb != null)
{
    rb.AddForce(...);
}
```

危险做法：如果 rb 为 null 会崩溃
rb.AddForce(...);  // 可能抛出异常


## Step4 修改playerAttack的传入方向

修改前
```
EnemyHealth enemy = hit.collider.GetComponent<EnemyHealth>();
// 直接调用，没有传递方向参数
enemy.TakeDamage(20);
```
修改后
```
if (enemy != null)
{
    // 计算攻击方向
    Vector3 hitDir = (hit.collider.transform.position - transform.position).normalized;
    // 传递方向参数
    enemy.TakeDamage(20, hitDir);
}
```

 Vector3 hitDir = (hit.collider.transform.position - transform.position).normalized;
理解过程
- hit.collider.transform.position
  - hit.collider：被击中的碰撞体
  - hit.collider.transform：碰撞体所在的游戏对象
  - hit.collider.transform.position：被击中敌人的世界坐标
- transform.position
  -  当前脚本所在游戏对象的Transform（就是脚本挂载到哪里了）
  -  transform.position：攻击者的世界坐标（通常是玩家或武器）

向量的减法： 敌人位置 - 玩家位置 = 从玩家指向敌人的向量

.normalized:标准化——击退力度就一致了，不会因为距离不同而产生不同的力；
否则的话方向向量的长度不统一，不会因为距离不同产生不同的力

    enemy.TakeDamage(20, hitDir);

原来只传播了伤害，现在还要传播前面算出来的方向

