# 实现第三人称摄像机跟随系统

TPS/3D 体验：摄像机跟随+平滑视角

玩家移动->摄像机移动

拆解摄像机系统

## 第三人称摄像机核心功能

**1、固定跟随玩家**：摄像机保持距离

**2、旋转控制**：左右旋转玩家、上下旋转摄像机视角

**3、平滑跟随**：避免抖动、舒适

```
Player (胶囊)
 ↑
 CameraTarget (空物体, 跟随Player)
      ↑
      Camera (实际摄像机)
```
摄像机不是直接跟着 Player，而是围绕 CameraTarget 转。

流程每帧:

1. 读取鼠标移动 → 改 CameraTarget 角度

2. 计算摄像机位置 = CameraTarget 后方一定距离 + 高度

3. Camera.LookAt(CameraTarget)

**为什么先做摄像机而不是射击？**

TPS射击的发射方向通常依赖摄像机

玩家开枪 → 射线方向 = 摄像机方向


**为什么要这样设计？**


因为我要实现这件事：

鼠标左右移动->让摄像机绕角色“水平旋转”

鼠标上下移动->让摄像机绕角色“上下旋转”

摄像机不穿角色->始终保持距离


## 计算摄像机的位置

**①在TPS游戏中，是第三人称摄像机**

数学本质
摄像机位置 = 角色位置 - 前方方向 × 距离 + 高度偏移
比喻：
玩家像一个"无形的摄影师"跟在角色后面
电影跟拍镜头，看着主角的背影

**②对于FPS，是第一人称摄像机**

摄像机位置 = 角色眼睛位置
摄像机朝向 = 角色朝向

```
实际游戏示例
《黑暗之魂》角色
玩家创建的角色 + 酷炫盔甲
如果第一人称：完全看不到自己的装备
第三人称：随时欣赏自己的造型，看攻击动作
```

## 鼠标移动的功能

在做这件事：
改变“旋转角度”
forward方向变了

摄像机位置就自动换了

这就是“绕点旋转”。


总结摄像机系统本质只有**三步**

**①读取鼠标输入**

得到两个值：鼠标左右移动量（控制水平旋转）、
鼠标上下移动量（控制垂直旋转）

**②更新旋转角度**

yaw = 左右旋转角
pitch = 上下旋转角

**③用角度算出摄像机的位置**

unity进行计算


**第一个问题：摄像机围绕谁转？**

我的理解：围绕角色旋转

精确答案：摄像机围绕CameraTarget转，而CameraTarget绑定在角色身上

**第二个问题：鼠标移动本质是什么？**

我的理解：改变摄像机角度 → Unity捕获并计算

精确答案：移动-> 读取输入值->改变两个变量yaw和pitch->两个角度设置到CameraTarget的rotation

->Unity根据rotation自动更新物体方向 -> 方向向量改变->摄像机位置改变

**在摄像机系统里，哪个物体应该旋转？**

我的回答：我觉得是player旋转，然后摄像机为了观测player的方向，需要和player保持方向一致。

正确答案：是由Player和Camera分工旋转。

左右旋转（Yaw）	   Player 整体旋转	   角色身体要朝移动/射击方向

上下旋转（Pitch）	CameraTarget 旋转	 角色身体不能仰头低头180°

**摄像机上下旋转过多会发生什么？**

我的理解：出现不合常理的部分。

答案：① 画面会“翻转”，往上转超过 90° 时：摄像机的“上方向”会反转，画面突然倒过来

3D坐标系的方向关系会反转，导致控制逻辑崩溃(这个就是数学问题、不是视觉问题)

②摄像机转到角色下方看上去：玩家能看到角色“肚子下面”。TPS的核心是：玩家永远站在角色后方观察。

③因为摄像机的“局部坐标系”翻转了，可能会导致左右上下有点混乱。

**所以要怎么解决？**

我们要限制 pitch 的范围：

只能在“低头看地面一点”到“抬头看天空一点”之间


行业常用范围：

pitch 限制在 -40° 到 +60° 之间


## 进入实战理解

**cameraController**

**变量区域**
```using UnityEngine;

public class CameraController : MonoBehaviour
{
    public float mouseSensitivity = 200f;
    //控制“鼠标一动，转多快”
    float yaw = 0f;
    float pitch = 0f;
  //这两个变量就是摄像机系统的“核心数据”。
    public Transform playerBody;
  //
}
```



**第二步：Start()**


```void Start()
{
    Cursor.lockState = CursorLockMode.Locked;
  
}
```
一共有三种：Locked、Confined、None

作用：鼠标所在屏幕中间+不会跑出屏幕

效果：
鼠标光标被锁定在窗口中心

鼠标不会显示（隐藏）

鼠标移动直接转换为游戏内的旋转输入

**第三步：Update()**
```
void Update()
{
    float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime;
    float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime;

    yaw += mouseX;
    pitch -= mouseY;


    pitch = Mathf.Clamp(pitch, -40f, 60f);

    transform.localRotation = Quaternion.Euler(pitch, 0f, 0f);
    playerBody.rotation = Quaternion.Euler(0f, yaw, 0f);

}
```

第三步内容的解读：

Input.GetAxis("Mouse X")----返回值：鼠标左右移动量、右移为证，左移为负

yaw += mouseX;     // 水平旋转（左右摇头）

<img width="206" height="294" alt="image" src="https://github.com/user-attachments/assets/62093062-21c0-477e-bf9f-2ebedbce3776" />

pitch -= mouseY;   // 垂直旋转（上下点头）

<img width="337" height="287" alt="image" src="https://github.com/user-attachments/assets/8cdcc897-8509-4f81-afb9-cf5a17992166" />

**为什么pitch -= mouseY？**
因为屏幕坐标和3D空间是反的：

鼠标方向 ：鼠标向上	

期望视角 ：看上面

但Y轴是向上为正，所以要反过来减。

注意**要限制pitch**：限制上下角度范围，防止翻转

**这里关于视角的旋转需要展开说：**

**现实世界里：**

**左右看** —— 转身体（腰）

你整个人朝左或朝右转

你的**“前进方向”也变**了

**上下看** —— 只动脖子（头）

你低头或抬头

但身体朝向没有改变

yaw（左右） → Player旋转→改变移动方向→人是转身体

pitch（上下） → Camera旋转→只改变视线→人是抬头低头

现在的结构是->**分层旋转结构（Hierarchical Rotation System）**

  Player (负责方向、移动)

    └── CameraTarget (负责头部上下转)

        └── Camera (真正拍画面)
