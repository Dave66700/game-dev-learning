死亡镜头冲击
原理

摄像机结构

player-cameraTarget-camera

因此不能移动player，也不可以改CameraTarget rotation

只移动Camera的localPosition

Step1
创建DeathCameraImpulse.cs

挂载到camera上

Step2

代码部分
```
using System.Collections;
using UnityEngine;

public class DeathCameraImpulse : MonoBehaviour
{
    Vector3 originalLocalPos;

    public float pushDistance = 0.4f;   // 前冲距离
    public float pushSpeed = 12f;       // 冲出去速度
    public float returnSpeed = 6f;      // 回弹速度

    void Start()
    {
        originalLocalPos = transform.localPosition;
    }

    public void PlayDeathImpulse()
    {
        StopAllCoroutines();
        StartCoroutine(Impulse());
    }

    IEnumerator Impulse()
    {
        Vector3 targetPos =
            originalLocalPos + Vector3.forward * pushDistance;

        // ===== 向前冲 =====
        float t = 0;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime * pushSpeed;
            transform.localPosition =
                Vector3.Lerp(originalLocalPos, targetPos, t);
            yield return null;
        }

        // ===== 停顿一点点 =====
        yield return new WaitForSecondsRealtime(0.05f);

        // ===== 慢慢回弹 =====
        t = 0;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime * returnSpeed;
            transform.localPosition =
                Vector3.Lerp(targetPos, originalLocalPos, t);
            yield return null;
        }
    }
}

```
解读

Step2-1变量
```
Vector3 originalLocalPos;    // 存储相机的原始局部位置
public float pushDistance = 0.4f;   // 向前冲击的距离
public float pushSpeed = 12f;       // 冲击出去的速度
public float returnSpeed = 6f;      // 回弹的速度
```

Step2-2start方法
```
void Start()
{
    originalLocalPos = transform.localPosition;  // 记录初始位置
}
```
开始时记录初始位置

Step2-3公共方法

```
 public void PlayDeathImpulse()
    {
        StopAllCoroutines();
        StartCoroutine(Impulse());
    }
```

- 第一个：停止正在运行的协程，防止重叠
- 就是coroutine，开始冲击效果

Step2-4协程部分

```
IEnumerator Impulse()
    {
        Vector3 targetPos =
            originalLocalPos + Vector3.forward * pushDistance;

        // ===== 向前冲 =====
        float t = 0;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime * pushSpeed;
            transform.localPosition =
                Vector3.Lerp(originalLocalPos, targetPos, t);
            yield return null;
        }

        // ===== 停顿一点点 =====
        yield return new WaitForSecondsRealtime(0.05f);

        // ===== 慢慢回弹 =====
        t = 0;
        while (t < 1f)
        {
            t += Time.unscaledDeltaTime * returnSpeed;
            transform.localPosition =
                Vector3.Lerp(targetPos, originalLocalPos, t);
            yield return null;
        }
    }
```

分为三个部分

1.向前冲阶段
- vector3 targetPos = originalLocalPos（原来相机的位置）+vector3.forward（固定向量，前方）*pushDistance（前面定义的）

- t += Time.unscaledDeltaTime * pushSpeed;
  - t变量是一个从0-1的插值因子
  - Lerp插值，0表示起点，1表示位置重点
  - 不断增加t的值来实现位置的平滑过渡
  - Time.unscaledDeltaTime * pushSpeed（12f表示每秒增加12）
    - 由于t只需要从0到1，所以完成前冲阶段实际需要的时间是：1/12 ≈ 0.083秒

- transform.localPosition = Vector3.Lerp(originalLocalPos, targetPos, t);
  - Vector3.Lerp(起点, 终点, 插值因子);
- yield return null;
  - 暂时暂停执行，下一帧继续从这里开始执行
  -  等待1帧
2.短暂停顿
-   yield return new WaitForSecondsRealtime(0.05f);
  - 等待0.05s，不受timescale影响    
3.回弹阶段
t = 0;
while (t < 1f)
{
    t += Time.unscaledDeltaTime * returnSpeed;
    transform.localPosition = Vector3.Lerp(targetPos, originalLocalPos, t);
    yield return null;
}

- t=0重置插值因子
- 其他的参考向前冲。是类似的。


Step3 GameManager 调用

- GameManager中
  - public DeathCameraImpulse deathImpulse;
  - 把Camera拖进去
- 死亡触发时
  - deathImpulse.PlayDeathImpulse();
  - 放在慢动作开始之前
  - <img width="516" height="354" alt="image" src="https://github.com/user-attachments/assets/9d1046e5-42ff-4031-affd-03c97f462247" />
