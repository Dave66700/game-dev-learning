# 玩家死亡慢动作

玩家死亡-世界进入慢动作-再完全静止

不是直接变成Time.timeScale = 0,是一个过度

时间线：
- 玩家死亡->0.2秒慢动作->完全暂停->GameOver

## Step1 - 修改GameManager

修改删除旧的直接暂停
- 删除旧的Time.timeScale = 0f;
- 删除

改为协程(Coroutine)

```
void OnGameOver()
{
    StartCoroutine(GameOverSequence());
}
```

## StartCoroutine 和 IEnumerator

我想要再了解二者。

实现逻辑：游戏结束——进入慢动作——等待0.25——暂停

### 不能用Thread.Sleep(250);

### Coroutine（协程）是什么

Coroutine = 可以中途暂停，下一帧继续执行的函数

like：

执行一点-暂停-下一帧继续-在暂停-再继续

### IEnumerator 是什么？


IEnumerator GameOverSequence()

表示这个函数不是一次执行完的，是一个可分段执行的流程

- 为什么必须写 IEnumerator？
  - 因为 Unity 要求：只有返回 IEnumerator 的函数才能被 Coroutine 系统控制。
 
### 真正重要的部分

yield return new WaitForSecondsRealtime(0.25f);

意思是：执行到这里，暂停这个函数等待0.25秒时间，然后接着往下进行

### StartCoroutine在干嘛

告诉：开始运行这个可暂停的流程

第一帧
```
Debug.Log("GAME OVER SEQUENCE");
Time.timeScale = 0.2f;
```

游戏计入慢动作。然后

yield return

协程暂停

0.25秒后（真是时间）

游戏完全暂停：Time.timeScale = 0f;

## Step2 死亡慢动作协程
```
IEnumerator GameOverSequence()
{
    Debug.Log("GAME OVER SEQUENCE");

    // 进入慢动作
    Time.timeScale = 0.2f;
    Time.fixedDeltaTime = 0.02f * Time.timeScale;

    // 等待真实时间（不受 timeScale 影响）
    yield return new WaitForSecondsRealtime(0.25f);

    // 完全停止
    Time.timeScale = 0f;
}

```

**为什么用WaitForSecondsRealtime**

前面已经改变了时间的规格也就是Time.timescale = 0.2f;

waitForSeconds(0.25f)等待时间也会被减慢。

 总结

StartCoroutine = 启动一个可暂停的流程

IEnumerator = 允许这个流程被暂停

yield return = 在这里暂停一会儿

**为什么要改 fixedDeltaTime？**

如果不该，慢动作时物理会抖动，击退/移动会奇怪

所以必须要同步缩放
```
Time.fixedDeltaTime = 0.02f * Time.timeScale;
```
